
Язык программирования Trac

Краткое введение

Язык программирования Trac по своей сути функциональный макроязык, адаптированный к компьютерам сильно ограниченным в своих ресурсах.
Тут и далее, я буду описывать слегка модифицированную версию Trac предназначенную для работы на микроконтроллерах. В настоящее время ведется разработка на ESP8266.

Отличия от изначальной версии Муэрса:
- ограничение длины имени пользовательской формы и команд - 8 байт вместо 2х
- внутреннее представление чисел при арифметических и логических операциях: 32-битное целое число вместо квази-неограниченной
- добавлены побитовые логические операции над целыми числами
- изменено внешнее представление чисел при логических операциях
- добавлено несколько полезных команд
- добавлено управление периферией процессора
- добавлена концепция обработки прерываний
- добавлены альтернативные имена функций
- добавлен сетевой доступ (telnet)

Язык Trac по своей концепции сильно отличается от большинства распространенных языков.
В основе всего лежит "цепочка" - по сути символьная строка. 
Текст - это цепочка символов, число - цепочка символов, массив это тоже цепочка символов, разбитая на поля некими спецсимволами.
Аналогично описываются любые простые структуры данных. Но что самое интересное - функция - это тоже просто цепочка символов.

Trac - процессор можно представить как:
- входные интерфейсы
- хранилище "форм" в оперативной памяти - по сути хранилище переменных и пользовательских функций
- интерпретатор
- хранилище блоков форм в файловой системе
- выходные интерфейсы

Программа на языке Trac предстовляет собой сочетание текстовых данных и функций. Функции бывают двух типов:
#() - активные функции, их результат будет послан на выполнение
##() - нейтральные функции, их результат будет сохранен, но не будет выполняться.
Есть одна особенность: если в результате выполнения нейтральной функции происходит обработанная ошибка - функция автоматически считается активной и ее обработчик ошибки - выполняется.

Первый параметр функции: ее имя. Параметры функций разделяются запятыми ",". Это одно из странно неудобных мест в языке: нельзя обрабатывать тексты содержащие запятые. Текст воспринимается как разбитый на несколько параметров.
Иногда последний параметр помечается как Z - это процедура обработки ошибок.
С ошибками в параметрах язык ведет себя чересчур вольно: недостающие параметры заменяются пустой строкой, избыточные параметры не принимаются во внимание. И при этом не генерится никаких ошибок.
Не менее вольно можно обращаться с именами пользовательских переменных и функций. Имя может быть любым набором ASCII символов, если оно влезает в 8 байт (ограничение этой версии) и не содержит запятых и "волшебных разделителей" (в этой версии это char(17),char(18),char(19) и char(20)).
То есть " " - разрешенное имя, "+1" - разрешенное имя и т.д. За вольность приходится платить внимательностью. Поскольку пробел - это реальный символ, то результатом #(ad,1,1) будет "2" - сумма двух единиц, а результатом #( ad, 1, 1) будет ничего поскольку функции " ad" нет (если вы ее специально для этого случая не создали). 

Классическая первая программа "Hello World!" на Trac выглядит так "#(ps,Hello World!)`" (без кавычек). Видно что некоторая избыточность присутствует, но она меньшечем в большинстве современных языков.
Впрочем избыточность тут не показатель. Например такая частая операция как присваивание (а функциональным языкам оно далеко не свойственно) съедает значителько больше места по сравнению с общеупотребительными языками: A = 10 выглядит как "#(ds,A,10)" (без кавычек).

Отдельного упоминания требует знак обратной тильды "`" - у Trac это называется "meta". В общем-то не нужный на современных языках дополнительный разделитель. Чо он дает?
Во первых - отдых процессору :) пока во входном буфере не появилась "`" - процессор может заняться другими делами.
Во вторых - программа "нарезается" на смысловые куски, которые не должны прерываться другими процессами - своего рода транзакции. Это позволяет создать подобие многопользовательской системы на одном общем ядре, и реализовать обработку прерываний (событий). Это также позволяет создавать оптимальные многопроцессорные решения... Пожалуй звучит странно "Интерпретатор на FPGA", но об этом стоит подумать.
В третьих - программист, расставляя меты, может оптимизировать использование оперативной памяти: частая их расстановка недогружает буферы интерпретатора, сокращает время реагирования на прерывания, но перегружает входные буфера, а редкая наоборот - разгружает входные буфера но может вызвать переполнение буферов интерпретатора.
Символ меты можно заменить на любой доступный (кроме запятой, круглых скобок и упомянутых выше "волшебных"), и потом вернуть на место. Пока не разобрались что он делает, можете для простоты заменить его на "\n" и до поры до времени упростить себе жизнь.
(От Автора: порой я замечаю в Trac концепции и идеи которые сейчас реализованы в весьма современных интерпретируемых языках - в том же javascript например, и поражаюсь что они реализованы НЕ ДО КОНЦА, иногда тому есть причины (безопасность например) но иногда объяснения тому нет)

Как это работает

Во входные буфера Trac-процессора поступают данные: от терминала, из сети, от устройств генерирующих прерывания, с диска. Это продолжается пока в одном из входных буферов не появляется символ meta.
После его появления, начинается жизнь: в "активный буфер" копируется цепочка idle = "#(ps,#(rs))", "нейтральный буфер" очищается. Далее в цикле происходит интерпретация активной цепочки слева направо. Выполнение команды "#(rs)" приводит к загрузке в хвост активной цепочки строки из буфера где появилась мета - от начала буфера до знака меты. Сама meta отбрасывается.
Зачем нужен "#(ps,)"? Он в случае чего выдаст сообщение об ошибке.
Далее начинается интерпретация загруженной из буфера строки. Говорят, что у Trac самый простой в мире интерпретатор... Это не точно. У него самый простой в Мире синтаксический разборщик - парсер.
Парсинг состоит всего из нескольких шагов:
1. Если активный буфер пуст загрузить в него idle, очистить нейтральный буфер.
2. Если первый символ активного буфера "(" найти парную ей закрывающую скобку. Скобки отбросить, то что было междлу ними переместить в конец нейтрального буфера.
3. Если первый символ "\t", "\n", "\r" просто выкидываем его из активной строки. 
4. Если первый символ "," выкидываем его, а в нейтральный буфер добавляем волшебный символ "конец аргумента".
5. Если первые три символа "##(" выкидываем их, а в нейтральный буфер добавляем волшебный символ "нейтральная функция".
6. Если первые два символа "#(" выкидываем их, а в нейтральный буфер добавляем волшебный символ "активная функция".
7. Если первый символ "#" переносим его в нейтральный буфер.
8. Если первый символ ")" значит это конец какой то  функции. Выкидываем его. В нейтральный буфер добавляем волшебные символы "конец аргумента", "конец функции". Ищем начало этой функции и передаем ее на обработку функций удалив из нейтрального буфера. Если функция активная, или нейтральная но при ее обработке возникли ошибки ее результат помещается в начало активного буфера, если нейтральная то в конец нейтрального буфера.
9. Если символ другой - переносим его в конец нейтрального буфера
(описание вольное, за подробным обратитесь к статье в этом же каталоге)
