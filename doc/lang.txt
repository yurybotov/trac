
Язык программирования Trac

Краткое введение

Язык программирования Trac по своей сути функциональный макроязык, адаптированный к компьютерам сильно ограниченным в своих ресурсах.
Тут и далее, я буду описывать слегка модифицированную версию Trac предназначенную для работы на микроконтроллерах. В настоящее время ведется разработка на ESP8266.

Отличия от изначальной версии Муэрса:
- ограничение длины имени пользовательской формы и команд - 8 байт вместо 2х
- внутреннее представление чисел при арифметических и логических операциях: 32-битное целое число вместо квази-неограниченной
- добавлены побитовые логические операции над целыми числами
- изменено внешнее представление чисел при логических операциях
- добавлено несколько полезных команд
- добавлено управление периферией процессора
- добавлена концепция обработки прерываний
- добавлены альтернативные имена функций
- добавлен сетевой доступ (telnet)

Язык Trac по своей концепции сильно отличается от большинства распространенных языков.
В основе всего лежит "цепочка" - по сути символьная строка. 
Текст - это цепочка символов, число - цепочка символов, массив это тоже цепочка символов, разбитая на поля некими спецсимволами.
Аналогично описываются любые простые структуры данных. Но что самое интересное - функция - это тоже просто цепочка символов.

Trac - процессор можно представить как:
- входные интерфейсы
- хранилище "форм" в оперативной памяти - по сути хранилище переменных и пользовательских функций
- интерпретатор
- хранилище блоков форм в файловой системе
- выходные интерфейсы

Программа на языке Trac предстовляет собой сочетание текстовых данных и функций. Функции бывают двух типов:
#() - активные функции, их результат будет послан на выполнение
##() - нейтральные функции, их результат будет сохранен, но не будет выполняться.
Есть одна особенность: если в результате выполнения нейтральной функции происходит обработанная ошибка - функция автоматически считается активной и ее обработчик ошибки - выполняется.

Первый параметр функции: ее имя. Параметры функций разделяются запятыми ",". Это одно из странно неудобных мест в языке: нельзя обрабатывать тексты содержащие запятые. Текст воспринимается как разбитый на несколько параметров.
Иногда последний параметр помечается как Z - это процедура обработки ошибок.
С ошибками в параметрах язык ведет себя чересчур вольно: недостающие параметры заменяются пустой строкой, избыточные параметры не принимаются во внимание. И при этом не генерится никаких ошибок.
Не менее вольно можно обращаться с именами пользовательских переменных и функций. Имя может быть любым набором ASCII символов, если оно влезает в 8 байт (ограничение этой версии) и не содержит запятых и "волшебных разделителей" (в этой версии это char(17),char(18),char(19) и char(20)).
То есть " " - разрешенное имя, "+1" - разрешенное имя и т.д. За вольность приходится платить внимательностью. Поскольку пробел - это реальный символ, то результатом #(ad,1,1) будет "2" - сумма двух единиц, а результатом #( ad, 1, 1) будет ничего поскольку функции " ad" нет (если вы ее специально для этого случая не создали). 

Классическая первая программа "Hello World!" на Trac выглядит так "#(ps,Hello World!)`" (без кавычек). Видно что некоторая избыточность присутствует, но она меньше чем в большинстве современных языков.
Впрочем избыточность тут не показатель. Например такая частая операция как присваивание (а функциональным языкам оно далеко не свойственно) съедает значителько больше места по сравнению с общеупотребительными языками: A = 10 выглядит как "#(ds,A,10)" (без кавычек).

Отдельного упоминания требует знак обратной тильды "`" - у Trac это называется "meta". В общем-то не нужный на современных языках дополнительный разделитель. Чо он дает?
Во первых - отдых процессору :) пока во входном буфере не появилась "`" - процессор может заняться другими делами.
Во вторых - программа "нарезается" на смысловые куски, которые не должны прерываться другими процессами - своего рода транзакции. Это позволяет создать подобие многопользовательской системы на одном общем ядре, и реализовать обработку прерываний (событий). Это также позволяет создавать оптимальные многопроцессорные решения... Пожалуй звучит странно "Интерпретатор на FPGA", но об этом стоит подумать.
В третьих - программист, расставляя меты, может оптимизировать использование оперативной памяти: частая их расстановка недогружает буферы интерпретатора, сокращает время реагирования на прерывания, но перегружает входные буфера, а редкая наоборот - разгружает входные буфера но может вызвать переполнение буферов интерпретатора.
Символ меты можно заменить на любой доступный (кроме запятой, круглых скобок и упомянутых выше "волшебных"), и потом вернуть на место. Пока не разобрались что он делает, можете для простоты заменить его на "\n" и до поры до времени упростить себе жизнь.
(От Автора: порой я замечаю в Trac концепции и идеи которые сейчас реализованы в весьма современных интерпретируемых языках - в том же javascript например, и поражаюсь что они реализованы НЕ ДО КОНЦА, иногда тому есть причины (безопасность например) но иногда объяснения тому нет)

Как это работает

Во входные буфера Trac-процессора поступают данные: от терминала, из сети, от устройств генерирующих прерывания, с диска. Это продолжается пока в одном из входных буферов не появляется символ meta.
После его появления, начинается жизнь: в "активный буфер" копируется цепочка idle = "#(ps,#(rs))", "нейтральный буфер" очищается. Далее в цикле происходит интерпретация активной цепочки слева направо. Выполнение команды "#(rs)" приводит к загрузке в хвост активной цепочки строки из буфера где появилась мета - от начала буфера до знака меты. Сама meta отбрасывается.
Зачем нужен "#(ps,)"? Он в случае чего выдаст сообщение об ошибке.
Далее начинается интерпретация загруженной из буфера строки. Говорят, что у Trac самый простой в мире интерпретатор... Это не точно. У него самый простой в Мире синтаксический разборщик - парсер.
Парсинг состоит всего из нескольких шагов:
1. Если активный буфер пуст загрузить в него idle, очистить нейтральный буфер.
2. Если первый символ активного буфера "(" найти парную ей закрывающую скобку. Скобки отбросить, то что было между ними переместить в конец нейтрального буфера.
3. Если первый символ "\t", "\n", "\r" просто выкидываем его из активной строки. 
4. Если первый символ "," выкидываем его, а в нейтральный буфер добавляем волшебный символ "конец аргумента".
5. Если первые три символа "##(" выкидываем их, а в нейтральный буфер добавляем волшебный символ "нейтральная функция".
6. Если первые два символа "#(" выкидываем их, а в нейтральный буфер добавляем волшебный символ "активная функция".
7. Если первый символ "#" переносим его в нейтральный буфер.
8. Если первый символ ")" значит это конец какой то  функции. Выкидываем его. В нейтральный буфер добавляем волшебные символы "конец аргумента", "конец функции". Ищем начало этой функции и передаем ее на обработку функций удалив из нейтрального буфера. Если функция активная, или нейтральная но при ее обработке возникли ошибки ее результат помещается в начало активного буфера, если нейтральная то в конец нейтрального буфера.
9. Если символ другой - переносим его в конец нейтрального буфера
(описание вольное, за подробным обратитесь к статье в этом же каталоге)
...

Зачем это нужно

Зачем нужен такой странный язык сейчас? Вроде бы есть куча других языков которые дают куда больше возможностей, куда более наглядны и быстры?
Ну например:
1. Вам нужно реализовать на микроконтроллере устройство, некоторые параметры которого необходимо оперативно подстраивать без участия разработчика: установщику или пользователю. Например IP адрес и SSID спота. Ну или пароль. Делается прошивка, в которую добавляем сильно обрезанный интерпретатор трака, зашивается в устройство. Пользователь через rs232 или telnet заходит на устройство, вводит несколько команд и все довольны.
2. Необходимо осложнить взлом устройства через открытый сетевой порт, но порт должен при этом постоянно принимать данные и както исполнять их. Берем интерпретатор трака, меняем все подряд управляющие символы. И спокойно посылаем полученную кашу на порт. Все работает, но со стороны выглядит неудобоваримо и разбираться в этом - то еще удовольствие для человека который синтаксиса трака не знает. 

Основы использования

...

Встроенные функции

1. Управление выполнением
#(rt) #(reset) - жестко рестартует весь контроллер
#(hl) #(halt) - остановить текущую программу, по сути мягко рестартует интерпретатор
#(eq,S1,S2,V1,V2) #(=,...) - условный оператор. Если S1 == S2 то возвращает V1 иначе V2
#(gr,S1,S2,V1,V2) #(>,...) - условный оператор. Если S1 > S2 то возвращает V1 иначе V2
#(lt,S1,S2,V1,V2) #(<,...) - условный оператор. Если S1 < S2 то возвращает V1 иначе V2

2. Ввод-вывод
#(gm) #(meta) - возвращает текущий символ мета.
#(cm,M) #(setmeta) - заменяет текущий символ мета на M. Возвращает пустую строку. 
#(rs[,Z]) #(read[,Z]),- читает из входного буфера строку от начала до символа мета и переносит ее в конец активной цепочки. Мету из буфера выкидываем. Если все нормально возвращает пустую строку, в случае ошибки Z.
#(rc) #(getchar) - читает из входного буфера один символ. Любой, включая мету. Возвращает этот символ.
#(ps,S) #(print,S) - отправляет строку S на текущее устройство вывода.
#(si[,N]) #(stdin[,N]) - подключить подсистему ввода к файлу с именем N, если #(si) - стандартный ввод из терминала. Возвращает пустую строку.
#(so[,N]) #(stdout[,N]) - подключить подсистему вывода к файлу с именем N, если #(so) - стандартный вывод на терминал. Возвращает пустую строку.

3. Арифметика
#(ad,D1,D2) #(+,...) - воспринимая D1 и D2 как десятичные числа складывает их и возвращает результат в виде строки.
#(su,D1,D2) #(-,...) - воспринимая D1 и D2 как десятичные числа вычитает D2 из D1 и возвращает результат в виде строки.
#(ml,D1,D2) #(*,...) - воспринимая D1 и D2 как десятичные числа перемножает их и возвращает результат в виде строки.
#(dv,D1,D2[,Z]) #(/,...) - воспринимая D1 и D2 как десятичные числа делит D1 на D2 и возвращает результат в виде строки, если D2 == 0 вместо результата возвращает Z.

4. Битовые операции
#(an,D1,D2) #(&,...) - возвращает побитовое И от чисел D1 и D2
#(or,D1,D2) #(|,...) - возвращает побитовое ИЛИ от чисел D1 и D2 
#(xr,D1,D2) #(^,...) - возвращает побитовое XOR от чисел D1 и D2
#(no,D1) #(!,D1) - возвращает побитовое NOT от числа D1
#(bs,D1,D2) #(<<,...) - возвращает D1 сдвинутое влево на D2 бит.
#(br,D1,D2) #(>>,...) - возвращает D1 сдвинутое вправо на D2 бит.

5. Отладка
#(np[,S]) #(nop[,S])- нет операции, можно использовать для временного скрытия кода S
#(nl[,S]) #(varlist) - возвращает список имен имеющихся форм, S - делимитер между именами форм
#(pb,S) #(varshow,S) - возвращает содержимое формы с именем S
#(tr) #(tron) - начать трассировку
#(tf) #(troff) - закончить трассировку

6. Формы
#(ds,N,S) #(define,...) - создает форму с именем N и значением S. Возвращает пустую строку.
#(ss,N,d1[,d2...]) #(split,...)- нарезка формы с именем N на сегменты ограниченные цепочками dx. Возвращает пустую строку.
#(сs,N[,Z]) #(nextnode,...) - вызов формы с именем N как список. Возвращает одну "следующую" запись из списка. Если записей нет или они закончились возвращает Z.
#(сс,N[,Z]) #(nextchar,...) - вызов формы N как массив символов. Возвращает один "следующий" символ. Если вернуть нечего возвращает Z.
#(сn,N,D[,Z]) #(nextfild,...)- вызов формы N как массив полей равной длины D. Возвращает D символов, при отрицательном D выдаются символы слева от маркера при положительном - справа. При ошибке возвращает Z.
#(fd,N,S[,Z]) #(findpos,..)- перемещение внутреннего указателя в форме N на начало найденной в форме подстроки S. Возвращает пустую строку, а при ошибке - Z.
#(сr,N) #(clearpos,...)- обнуление внутреннего указателя в форме N. Возвращает пустую строку.
#(dd,N) #(delete,...)- удаление формы N. Возвращает пустую строку.
#(da) #(delall) - удаление всех форм. Возвращает пустую строку.
#(sb,N,n1[,n2...]) #(save,...) - сохранение форм n1.. в блок на диске с именем N. Возвращает пустую строку.
#(fb,N) #(load,...) - загрузить все формы из блока на диске с именем N. Возвращает пустую строку.
#(eb,N) #(erase,...) - удалить блок на диске с именем N. Возвращает пустую строку.

7. Пользователи
#(un) #(user) - возвращает имя текщего пользователя
#(us,n) #(setuser,n) - делает текущим пользователем пользователя с номером n. Возвращает пустую строку.

