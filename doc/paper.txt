ОТ ПЕРЕВОДЧИКА
При работе над реализацией языка Trac я столкнулся с отсутствием русскоязычной информации по теме,
а автоматические переводчики несли такую чушь что проще было было застрелиться. Ошибки в оригинале
тоже совсем не радовали. 
Это подвигло меня на подготовку данного, к слову, крайне вольного стилистически, однако более-менее точного
по смыслу перевода.
Юрий Ботов 

TRAC, A Procedure-Describing Language for the Reactive Typewriter
TRAC, Язык описания процедур для пишущей машинки с турбонаддувом

by Calvin N. Mooers (1965)
написано Кельвином Муэрсом в 1965 году. Перевод 2014 года.

Статья предоставлена на конференции ACM Programming Languages and Pragmatics Conference, San Dimas, California, August 1965.


Описание

Предоставлено описание языка Trac (Text Reckoning And Compiling) и алгоритм его работы. Язык Trac был создан для реализации
концепции пишущей машинки с турбонаддувом. Язык позволяет принимать, обзывать и сохранять любую строку с консоли, изменять
любую строку в любое время, воспринимать любую строку как выполняемую процедуру, или как имя или как просто текст. Ну и само
собой печатать любую строку. Язык Traс, базируется на программной концепции "macro"-языка. Благодаря возможности определения
и сохранения процедур язык является бесконечно расширяемым (в пределах памяти пишущей машинки). Trac поддерживает итерации и 
рекурсию и может обрабатывать строки, целые числа и логические выражения, а также их массивы.

Данная работа выполнялась при поддержке: Advanced Research Projects Agency contract SD-295, Information Sciences Branch of 
the Air Force Office of Scientific Research contracts AF-AFOSR 376, 377 and 461-64, and Division of General Medicine, 
National Institutes of Health, U.S. Public Health Service грант GM 10416.


Содержание

Введение
TRAC синтаксис
Примеры функций
TRAC алгоритм
Функции TRAC
 Ввод-вывод
 Опраделение и вызов
 Арифметические функции
 Булевы функции
 Фукции ветвления
 Функции управления внешним хранилищем
 Диагностические функции
Примеры программ 


Введение

Система Trac (Text Reckoning And Compiling) включает в себя управление компьютером, внешним хранилищем и пишушей машинкой с 
турбонаддувом. Под этим подразумевается одна или несколько постоянно подключенных консолей которые разделяют общие ресурсы 
компьютера в режиме разделения времени. В философии печатной машинки с турбонаддувом человек за ней сидящий является фокусом
всей системы все остальное - просто сервисы.

Цель оздания языка Trac и системы трансляции включает: 
(1) максимальное удобство для пользователя такие как возможность делать вставки и вмешательство в процесс работы программы; 
(2) максимальная универсальность определений и производительность грамотно написанных процедур; 
(3) возможность  определения, хранения, и повторного использования процедур, расширение возможностей языка, и наконец...
(4) максимальная ясность языка и легкость обучения. Рассуждения о целях создания языка и решениях реализации вы можете найти в статье [1]. 
TRAC сейчас работает на нескольких компьютерах и показывает высокую стабильность по прошествии последнего года эксплуатации.

Язык TRAC машинонезависимый и очень удобен при работе на существующих консолях. Данная версия создавалась как "TRAC 64." 
В последующих версиях TRAC планируется добавить встраиваемые подпрограммы в машинных кодах.

Мы занялись Trac после изучения большого количества других языков, у каждого изи них были свои особенности, которые по нашему пониманию
не отвечали целям которые мы ставим перед Trac.
Например мы оценивали языки IPL-V, LISP и COMIT. Короче, IPL-V признан слишком ориентированным на программирование компьютера. 
LIPS (опечатка оригинала) имел ограничения из за его "атомной" модели, обладал определенным бардаком в концепциях, и был очень уж 
заточен под математическую логику. COMIT, нам весьма понравившийся, был жестко привязан к компилятору. 
Когда мы начали работать над TRAC (1960) подходящих вариантов не было, и это давало нам чувство особого вдохновения.

Главный стимул для создания TRAC пришел из двух важных статей Иствуда и Макилроя [3] и Макилроя [4]. Первая статья описывала
макро-подход имеющий возможность создания определений и принятия решений во время выполнения. Вторая статья показала возможность 
этого макро-подхода для манипулирования последовательностями символов. Trac это обработка и расширение данного подхода к программированию.
 
Можно сказать. что существующая система Trac состоит из машиннонезависимого языка и обобщенного макропросессора который управляет 
интерпретацией, которые обеспечивают высокие интерактивные возможности. Сошлюсь, независимо разработанная система Strachey [5] 
имеет много общего с TRAC.


Синтаксис TRAC

Строки в Trac могут содержать подстроки заключенные в парные круглые скобки ( ). Парные скобки указывают на место неких особых действий.
Есть три варианта помечаемых как #(...), ##(...) и (...) [замечание переводчика: в исходной статье опечатка - второй вариант указан 
как # #(···) - это неправильно]. Первые два варианта описывают функции-примитивы языка. Вид #(...) называется активной функцией, а 
##(...) - нейтральной функцией. Разницу опишем ниже. Любые виды функций как правило внутри разделяются на подстроки символами запятой ','
например #( , , ), эти подстроки являются аргументами функции. Парные скобки вида (...) имеют роль пометки текстового блока, и в 
некоторых случаях защищают заключенный в них код от выполнения.

Строки обрабатываются процессором Trac в соответствии с алгоритмом слева направо, а вычисление вложенных функций происходит изнутри-наружу.
[от переводчика: точнее "вычисление вложенных функций происходит в порядке достижения маркером интерпретатора их закрывающих скобок"]
Так в выражении функции будут выполнены в указанной последовательности: 

#( , #( , ,#( ),##( ) ) )

4    3     1     2

После выполнения функции ее тело убирается из строки, а на занимемое ею ранее место помещается строка, возможно пустая, которую вернула 
данная функция. Строка которую вернула активная функция повторно обрабатывается интерпретатором не смотря на защитные парные скобки ( ), 
результат пассивной функции - не обрабатывается.


Примеры функций

Пример использования функции-примитива "define string" это выражение #(ds,AA,CAT). Это выражение создает в памяти строковую переменную 
с именем "AA" и значением "CAT". Извлечь значение переменной из памяти можно используя функцию "call" #(cl,AA) . В результате работы функция
"call" помещает на свое место строку "CAT" которая была расположена в переменной "AA". Функция "define string" возвратит на место где она 
раньше была пустую строку [null]. Не одна из функций не остается на своем месте после выполнения, все удаляются и замещаются их результатом.

Вычисление функции "read string" #(rs) заставляет процессор читать строку с клавиатуры [в общем случае "из входного потока"]. Входной поток 
читается и помещается в строку пока в нем не встретится "метасимвол" [обычно апостроф - `]. При необходимости можно выбрать в качестве 
метасимвола другой символ. [вставка переводчика о метасимволе: странная вроде вещь этот метасимвол. Вроде есть конец строки - что еще надо?
Чтобы понять зачем он нужен надо представить себе что памяти в компьютере всего 8 килобайт, размер рабочего буфера интерпретатора всего 64 байта.
Эти метасимволы "рассыпали" по тексту программы так, чтобы не вызвать переполнение буферов. Сейчас эта проблема актуальна только на микроконтроллерах].
Функция "print string" #(ps,X) печатает [на текущее выходное устройство] значение своего единственного аргумента, то есть символ "X". 
Эта функция возвращает пустую строку. Вложенная конструкция #(ps,#(cl,AA)) таким образом, напечатает "CAT" и вернет пустую строку.

Пока пользователь не ввел программу, а также после выполнения пользовательской программы процессор Trac исполняет так называемую "idling procedure" 
#(ps,#(rs)) которая автоматически загружается в трак процессор. Все вводимые пользователем строки и программы таким образом оказываются вложенными в эту
"idling procedure".


Алгоритм Trac

Алгоритм Trac это описание процесса в котором Trac процессор сканирует и обрабатывает входные строки. Сначала, строка помещается в буфер
"active string" и "scanning pointer" устанавливается на начало этой строки. В результате интерпретации, символ на который указывает "scanning pointer"
может быть удален или перемещен в конец "neutral string" которая так называется потому, что символы в ней уже обработаны интерпретатором и 
дальнейшей обработке не подлежат. Алгоритм следующий:
1. Проверяем символ в "active string" на который указывает "scanning pointer". Если "active string" пуста, переходим к правилу 14.
2. Если символ на который указывает "scanning pointer" это открывающая скобка '(' то удаляем его из "active string", ищем закрывающую скобку 
парную найденной открывающей [с учетом вложенных] и переносим "scanning pointer" на нее. Удаляем закрывающую скобку. Неудаленные символы через 
которые перепрыгнул на предыдущем шагу "scanning pointer" [то что было между скобками] переносим без изменений в конец "neutral string". Переходим к правилу 1.
3. Если символ это CR,LF или TAB он просто удаляется. Переходим к правилу 15.
4. Если символ - запятая ',' удаляем его. В конец "neutral string" добавляем служебный символ "end of argument". Переходим к правилу 15.
5. Если символ - решетка '#' проверяем следующий за ним символ. Если следующий символ - открывающая скобка "(" то это начало активной функции.
Удаляем оба символа из "active string". В конец "neutral string" добавляем служебный символ "beginning of an active function". Переходим к 
правилу 15.[в оригинале было немного не так, но так понятнее] 
6. Если символ - решетка '#' проверяем следующий за ним символ. Если второй символ тоже решетка проверяем третий символ. Если третий символ - открывающая 
скобка "(" то это начало нейтральной функции. Удаляем из "active string" эти три символа. В конец "neutral string" добавляем служебный символ 
"beginning of an neytral function". Переходим к правилу 15. [в оригинале было немного не так, но так понятнее]
7. Если символ - решетка '#' и следующий за ним символ не совпал ни в правиле 5 ни в правиле 6, символ добавляется в конец "neutral string". 
Переходим к правилу 15.
8. Если символ - закрывающая скобка ')' удаляем его. В конец "neutral string" добавляем служебные символы "end of argument" и "end of function".
Ищем в "neutral string" последний символ "beginning of an active function" или "beginning of an neytral function". Теперь между найденным началом 
функции и концом строки сформирован полный набор аргументов данной функции разделенных символом "end of argument". Выполняем функцию. Переходим к 
правилам 10, 11 или 12 в зависимости что это за функция. [в оригинале указано только 10 но это не правильно]
9. Если символ другой, не попавший под правила с 2 по 8, переносим символ в конец "neutral string" и переходим к правилу 15.
10. Если функция возвращает пустую строку (не важно, активная или нейтральная) переходим к правилу 13. 
11. Если это активная функция возвращающая значение, добавить это в начало "active string", перед первым непросмотренным символом. Переместить 
"scanning pointer" на начало возвращенного значения. Перейти к правилу 13.
12. Если эта функция нейтральная то сначала удалить из "neutral string" все аргументы функции, включая все принадлежащие ей управляющие символы,
затем на это место добавить результат выполнения функции. Перейти к правилу 15.
13. Удалить из "neutral string" все аргументы функции, включая все принадлежащие ей управляющие символы, затем перейти к правилу 15.
14. Удаляем "neutral string" обнуляем ее указатель, загружаем в "active string" новую копию "idling procedure", устанавливаем "scanning pointer" 
на начало "idling procedure", возвращаемся к правилу 1.
15. Перемещаем "scanning pointer" к следующему символу в "active string". Переходим к правилу 1.

Trac процессор принимает символьную строку. При обращении к несуществующей функции возвращает пустую строку. Недостающие аргументы заменяются 
на значение пустая строка, излишние аргументы игнорируются. Нехватка правых скобок приводит к остановке программы и перезагрузке Trac процессора. 
Избыток правых скобок игнорируется, они удаляются по завершении выполнения. При переполнении счетчиков, вызванных скорее всего бесконечной 
рекурсией или итерацией, Trac процессор выдает соответствующее диагностическое сообщение и уходит в перезагрузку в соответствии с правилом 14.
Кнопка Break останавливает любые вычисления и производит перезагрузку Trac процессора.


Функции Trac 

Ввод-вывод

Все функции даются в их активном написании, поскольку оно чаще применяется. Аргументы не содержат других функций или иного активного 
содержимого.

#(rs) "read string" "читать строку" (1 аргумент). (Учтите что первый аргумент функции всегда это ее имя) Возвращает строку
набранную на клавиатуре [на самом деле из "входного потока" который не обязательно клавиатура]. Признак окончания ввода - метасимвол, 
из строки результата он удаляется.

#(rc) "read character" "читать символ" (1 аргумент). Возвращает строку из одного любого символа, включая метасимвол, прочитанного 
с клавиатуры. 

#(cm,X) "change meta" "изменить метасимвол" (2 аргумента). Функция изменяет значение ожидаемого метасимвола на X. Возвращает пустую строку.
При старте системы метасимвол будет восстановлен в стандартное значение: апостроф "`".

#(ps,X) "print string" "напечатать строку" (2 аргумента). Печатает X на консоли. Возвращает пустую строку.


Функции работы с формами (переменными)

#(ds,N,X) "define string" "определить строку" (3 аргумента). В хранилище форм создается переменная с именем N и значением X. 
Форма - это именованная строка в хранилище. Если в хранилище уже есть строка с таким именем - она удаляется, в место нее записывается новая форма.
Имя формы N может быть пустой строкой. Функция возвращает пустую строку. [В наше время то что тут названо "Формой" называется сочетанием "ключ-значение"]

#(ss,N,X1,···) "segment string" "сегментировать строку" (3 и более аргументов). Строка значения формы N извлекается из формы. Для этой строки
выполняется операция замены всех вхождений строк X1...XN на спецсимволы "segment gap" [состоящие из 2 символов: 0xFF и (1...N) в 
соответствии с номером аргумента]. После обработки, полученная строка записывается обратно в форму N. Строки между спецсимволами называются
"segments." Данная функция создает макроопределение, готовит строку для использования с переменными (по порядковым номерам переменных).
Теперь эта строка может вызываться с различными аргументами. Функция ss может быть вызвана по отношении к одной и той же форме несколько раз с 
разными аргументами, при этом порядковый номер "segment gap" автоматически увеличивается. Пустая строка в аргументе ss - игнорируется. 
Функция возвращает пустую строку. [Написано путанно, в оригинале - еще похлеще. Данная функция просто размечает в строке поля для макроподстановки]

#(cl,N,X1,X2,···)[от переводчика: в оригинале опечатка, функцию назвали #(d,) в других местах по тексту она встречается именно как #(cl,)] 
"call" "вызвать" (2 или более аргументов). Строка значения формы N извлекается из формы. Для этой строки выполняется операция замены 
всех вхождений спецсимволов "segment gap" на строки X1...XN. Если параметров меньше чем количество порядковых номеров "segment gap" 
оставшиеся "segment gap" заменяются пустыми строками. Полученная строка возвращается в качестве результата.[ в другой статье Муэрс указал
что можно эту функцию вызывать и без имени: #(N,X1,X2,···) что делает абсолютно прозрачным обращение к функциям пользователя, в стандарт это
потом тоже добавили]

Следующие специализированные "call" позволяют получить доступ к частям формы. Они игнорируют символы "segment gap". Эти вызовы (cs, cc, 
сn и in) различают активные или нейтральные функций только по отношению к результату полученному из формы (с именем N), результат 
который вернулся из поля альтернативного результата Z - всегда обрабатывается как будто функция активная.[это позволяет помещать в поле
Z код обработки ошибки]
Все эти функции (cs, cc, сn и in) начинают читать строку из формы с места на которое указывает счетчик "form pointer" который сохранен 
в форме. Изначально он указывает на первый символ формы.

#(cs,N,Z) "call segment" "загрузить сегмент" (3 аргумента). Значение этой функции - строка от текущего положения "form pointer" до следующего
спецсимвола "segment gap". "Form pointer" перемещается на символ следующий за найденным "segment gap". Если форма пуста возвращается значение
аргумента Z функции. [По сути это позволяет обращаться к строке как к массиву строк]

#(cc,N,Z) "call character" "загрузить символ" (3 аргумента). Значение функции строка из одного символа на который указывает "form pointer" 
в форме N. "Form pointer" перемещается вперед на один символ, если это "segment gap" то на символ следующий за "segment gap". Если форма 
пуста возвращается значение аргумента Z функции. [По сути это позволяет обращаться к строке как к массиву символов]

#(cn,N,D,Z) "call n characters" "загрузить n-символов" (4 аргумента). Значение функции строка из D символов на начало которых указывает 
"form pointer" в форме N. Символы "segment gap" отбрасываются. Если D положительное то считываются символы справа от "form pointer", если
отрицательное то слева. Последовательность символов во втором случае сохраняется слева направо. Если читать нечего возвращается значение 
аргумента Z. "Form pointer" перемещается вправо на D символов (плюс если есть "segment gap") если D положительное, или влево, если D 
отрицательное. [Это также позволяет обращаться к строке как к массиву строк или форматированных чисел]

#(cr,N) "call restore" "сбросить указатель" (2 аргумента). Возвращает "form pointer" формы с именем N в исходное положение: на начало формы.

#(dd,N1,N2,···) "delete definition" "удалить определение" (2 или более аргументов). Удаляет из хранилища формы с именами из аргументов 
функции. Возвращает пустую строку.

#(da) "delete all" "удалить все" (1 аргумент). Удаляет все формы из хранилища. Возвращает пустую строку.


Арифметические функции

Trac использует целочисленную арифметику в десятичной системе счисления. Не должно быть пробелов между числом и признаком конца аргумента.
Префикс первого аргумента сохраняется и добавляется в результат, префикс второго аргумента игнорируется. Отрицательные числа  помечаются 
знаком минус '-', лидирующие нули отбрасываются. При переполнениях при вычислении, вместо строкового значения результата возвращается
значение аргумента Z. Если возвращается значение Z, любая функция ведет себя как активная. (Z передается на исполнение). Арифметические 
функции:
#(ad,D1,D2,Z) "прибавить"
#(su,D1,D2,Z) "вычесть" D1-D2
#(ml,D1,D2,Z) "умножить"
#(dv,D1,D2,Z) "делить". В1/В2
Все имеют 4 аргумента. D2 вычитается из D1, D1 делится на D2 с округлением вверх.


Булевы функции

Булевы функции Trac оперируют строками бит (с значениями 0 или 1), так называемыми булевыми векторами. Строка бит представляется
восьмеричным числом, каждое такое число занимает 3 бита. Поэтому битовая строка занимает в 3 раза больше места. Восьмеричные числа 
имеют префикс 0, например 00, 01. Любые другие префиксы отбрасываются. Булевы функции:
#(bu,01,02) "Boolean union" - OR
#(bi,01,02) "Boolean intersection," - AND 
#(bc,01)	"Boolean complement," - XOR 
#(bs,D1,01) "Boolean shift" - сдвиг влево если D1 > 0 или вправа если D1 < 0, заполняя освобожденное место 0
#(br,D1,01) "Boolean rotate" - кольцевой сдвиг влево если D1 > 0 или вправа если D1 < 0, заполняя освобожденное место 0
Битовая строка выравнивается по правому краю. В #(bu,) короткие строки дополняются лидирующими нулями, а в #(bi,) длинные строки 
усекаются слева, до длины более короткой строки. В остальных функциях длина строки не меняется. 


Функции сравнения

#(eq,X1,X2,X3,X4) "equals" "если равно" (5 аргументов). Условное ветвление. Если X1 равен X2, тогда возвращается значение X3 иначе
возвращается значение X4.

#(gr,D1,D2,X1,X2) "greater than" "если больше" (5 аргументов). Условное ветвление. Если D1 больше D2, тогда возвращается значение 
X1 иначе возвращается значение X2.


Функции обращения к внешнему хранилищу

#(sb,N,N1,N2,···) "store block" "сохранить блок" (3 или более аргументов). Эта функция собирает формы с перечисленными в аргументах N1...
именами в блок который сохраняет во внешнем хранилище. Сохраняется все: имена, положения указателей, служебные символы и т.д.
После сохранения перечисленные формы удаляются из хранилища форм. Создается новая форма с именем N  с значением равным адресу блока 
во внешнем хранилище. Функция возвращает пустую строку.

#(fb,N) "fetch block" "загрузить блок" (2 аргумента). Функция загружает из блока внешнего хранилища сохраненные ранее командой #(sb,)
формы. N имя формы в которой хранится адрес блока во внешнем хранилище. Восстанавливается все: имена, положения указателей, служебные 
символы и т.д. Функция возвращает пустую строку.

#(eb,N) "erase block" "стереть блок" (2 аргумента). Функция удаляет форму с именем N и блок данных во внешнем хранилище адрес которого
хранился в форме с именем N. Функция возвращает пустую строку.

Эти функции позволяют перемещать формы между основной и внешней памятью, это предохраняет формы от случайного удаления. Еще возникает 
возможность создать "дерево хранилищ". По этой технологии группы форм сохраняются под групповым именем, а набор групповых имен 
сохраняется под именем секции и так далее. [Да с памятью тогда был вообще швах...]


Диагностические функции

#(ln,X) "list names" "список имен" (2 аргумента). Значение этой функции это список всех имен форм (переменных и процедур) хранящихся
сейчас в памяти. Второй аргумент - строка разделитель между именами в выдаваемом списке. Напимер если 2 параметр CRLF то имена 
будут распечатаны в столбик, если запятая - то через запятую.

#(pf,N) "print form" "печатать форму" (2 аргумента). Печатает форму по имени N с указанием сегментной разметки.

#(tn) "trace on" "начать трассировку" (1 аргумент). Инициирует режим трассировки. В режиме вычисления печатается значение 
нейтральной строки для каждой из функции. Нажатие на BackSpace или Enter вызывают выполнение следующей функции, а нажатие любой 
другой кнопки вызывает перезагрузку.

#(tf) "trace off" (1 аргумент). Выключает режим трассировки. Как #(tn) так и #(tf) могут располагаться в любых точках программы 


Примеры программ на Trac

1. Различия между активными и нейтральными функциями обычно озадачивают. По сути, результат активной функции обрабатывается 
интерпретатором заново, а результат нейтральной - нет. Следующие примеры показывают как работает экранирование скобками, при 
использовании активных и нейтральных функций. Сначала создадим 2 переменные AA и BB:

#(ds,AA,CAT)'
#(ds,BB,(#(cl,AA)))'

После это следующие примеры напечатают соответствующие результаты:

#(ps,(#(cl,BB)))'	-> #(cl,BB)
#(ps,##(cl,BB))'	-> #(cl,AA)
#(ps,#(cl,BB))'		-> CAT

2. В случаях когда память уже перегружена, часто возникает желание удалить все переменные кроме одной - нужной. Это делает 
следующая проседура: #(ds,N,##(cl,N)#(da)) Тут ##(cl,N) читает нужную нам форму [переменную] и сохраняет ее в нейтральной 
строке процессора пока не выполнится удаление всех форм #(da) . Потом сохраненная форма определяется заново под прежним именем.
Правда существующая разметка на сегменты - теряется.

3. Этот и следующий примеры показывают как расширять возможности языка благодаря определению процедур. Вычисление
факториала также демонстрирует простую рекурсию: 

#(ds,Factorial,(#(eq,1,X,1,
(#(ml,X,#(cl,Factorial,#(ad,X,-1))))
)))#(ss,Factorial,X)'

Теперь вызов #(cl,Factorial,5)' вернет результат 120.

4. Многие пользователи хотят иметь Trac но с другими управляющими символами вместо '#','(',')'. Делается это так:

#(ds,English,(#(ps,
#(cl,#(rs))(#()
))#(cl,English)))'

[от переводчика: пример не полон, тут только часть кода и поэтому выполняться он не будет]

Для того чтобы перевести машину в этот режим мы используем #(cl,English)' и в результате команда in Factorial,5' [CRLF] вернет 
результат 120 . Выход из режима #(dd,English)' .

Благодарности. Особое спасибо моему сотруднику L. Peter Deutsch за помощь в создании и реализации TRAC.

Ссылки на литературу:
1.Mooers, C. N. TRAC, a text handling language. Proc. ACM 20th Nat. Conf. Cleveland, Aug. 1965, pp. 229-246. 
2.TRAC--a procedure defining and executing system. Mem. V-157, Rockford Research, Cambridge, June 1964. 
3.Eastwood, D. E., and McIlroy, M. D. Macro compiler modification of SAP. Mem., Comput. Lab., Bell Telephone Labs., Murray Hill, N.J., Sept. 3, 1959. (Unpublished) 
4.McIlroy, M. D. Using SAP macro instructions to manipulate symbolic expressions. Mem., Comput. Lab., Bell Telephone Labs., Murray Hill, N.J., 1960. (Unpublished) 
5.Strachey, C. A general purpose macrogenerator. COMPUT. J. 8, 3 (1966). 


© Copyright 2000 by The TRAC Foundation, Inc. (ноги бы им оторвать за такое количество ошибок при переносе с бумаги в файл)
